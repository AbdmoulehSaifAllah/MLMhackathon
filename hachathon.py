# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uuyD6K3qj7nxXoP52noRNKrI1JRPcuxk
"""

import pandas as pd

# Read in the CSV file
dataset = pd.read_csv("ML-Arxiv-Papers.csv", delimiter="\t")

# Print the first few rows of the dataset
print(dataset.head())
print(dataset)

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping

# Load the data from a CSV file
data = pd.read_csv("ML-Arxiv-Papers.csv")

# Identify missing values in the data
missing_values = data.isnull().sum()

# Print the number of missing values for each column
print(missing_values)

# Replace missing values with a suitable value (e.g. the mean or median)
data.fillna(data.mean(), inplace=True)

# Convert the data to a NumPy array
data_array = data.to_numpy()

# Split the data into training and validation sets
x_train, x_val, y_train, y_val = train_test_split(data_array[:, :-1], data_array[:, -1], test_size=0.2, random_state=42)

# Define the model architecture
model = Sequential([
    Dense(32, activation='relu', input_shape=(x_train.shape[1],)),
    Dense(16, activation='relu'),
    Dense(1, activation='sigmoid')
])

# Define the hyperparameters
learning_rate = 0.001
batch_size = 32
epochs = 100

# Compile the model with an optimizer and loss function
optimizer = Adam(learning_rate=learning_rate)
loss = 'binary_crossentropy'
metrics = ['accuracy']
model.compile(optimizer=optimizer, loss=loss, metrics=metrics)

# Define early stopping
early_stop = EarlyStopping(monitor='val_loss', patience=5)

# Train the model on the training data
history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, validation_data=(x_val, y_val), callbacks=[early_stop])

# Evaluate the model on the test data
loss, accuracy = model.evaluate(x_val, y_val)
print("Loss: {:.4f}, Accuracy: {:.4f}".format(loss, accuracy))